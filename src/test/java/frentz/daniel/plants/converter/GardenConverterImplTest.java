package frentz.daniel.plants.converter;

import frentz.daniel.garden.model.Garden;
import frentz.daniel.garden.model.GardenHardwareController;
import frentz.daniel.garden.model.Plant;
import frentz.daniel.hardwareservice.client.service.HardwareClient;
import frentz.daniel.plants.entity.GardenEntity;
import frentz.daniel.plants.entity.PlantEntity;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.same;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class GardenConverterImplTest {
    @Mock
    private PlantConverter plantConverter;
    @Mock
    private HardwareClient hardwareClient;
    @Mock
    private GardenHardwareControllerConverter gardenHardwareControllerConverter;
    @InjectMocks
    private GardenConverterImpl gardenConverter;


    @Test
    /**
     * Given a valid GardenEntity
     * When the method toGarden is called on the GardenConverterImpl
     * 1. The method should return a Garden
     * 2. The Garden should have the same id as the GardenEntity
     * 3. The Garden should have the same name as the GardenEntity
     * 4. The Garden should have the same plants as the GardenEntity
     * When the fetchHardwareControllers flag is true
     * 5. The Garden should have a GardenHardwareController generated by the GardenHardwareControllerConverter
     */
    void toGarden_mapAllFields_exceptController() {
        GardenEntity gardenEntity = new GardenEntity();
        gardenEntity.setId(1L);
        gardenEntity.setName("TestGarden");
        gardenEntity.setDescription("TestDescription");
        List<PlantEntity> plantEntities = List.of(new PlantEntity(), new PlantEntity());
        gardenEntity.setPlants(plantEntities);
        List<Plant> resultPlants = List.of(new Plant(), new Plant());
        when(this.plantConverter.toModels(same(plantEntities))).thenReturn(resultPlants);

        Garden garden = gardenConverter.toGarden(gardenEntity);

        assertEquals(gardenEntity.getId(), garden.getId());
        assertEquals(gardenEntity.getName(), garden.getName());
        assertEquals(gardenEntity.getDescription(), garden.getDescription());
        assertSame(resultPlants, garden.getPlants());
    }

    /**
     * Given a valid GardenEntity with a non zero controllerId
     * when the method toGarden is called on the GardenConverterImpl
     * 1. The method should return a Garden
     * 2. The Garden should have a GardenHardwareController generated by the GardenHardwareControllerConverter
     */
    @Test
    void toGarden_mapController_whenTheControllerIdIsNonZero() {
        GardenEntity gardenEntity = new GardenEntity();
        gardenEntity.setControllerId(1L);
        GardenHardwareController hardwareController = new GardenHardwareController();
        when(this.gardenHardwareControllerConverter.toGardenHardwareController(gardenEntity.getControllerId())).thenReturn(hardwareController);

        Garden garden = gardenConverter.toGarden(gardenEntity);

        assertNotNull(garden.getHardwareController());
        assertSame(hardwareController, garden.getHardwareController());
    }

    /**
     * Given a valid GardenEntity with a zero controllerId
     * when the method toGarden is called on the GardenConverterImpl
     * 1. The method should return a Garden
     * 2. The Garden should not have a GardenHardwareController
     */
    @Test
    void toGarden_mapController_whenTheControllerIdIsZero() {
        GardenEntity gardenEntity = new GardenEntity();
        gardenEntity.setControllerId(0L);

        Garden garden = gardenConverter.toGarden(gardenEntity);

        assertNull(garden.getHardwareController());
    }

    @Test
    /**
     * Given a list of GardenEntities with a single GardenEntity
     * When the method toGardens is called on the GardenConverterImpl
     * 1. The method should return a list with a single Garden
     */
    void toGardens_withSingleGarden() {
        GardenEntity gardenEntity = new GardenEntity();
        List<GardenEntity> gardenEntities = List.of(gardenEntity);

        List<Garden> gardens = gardenConverter.toGardens(gardenEntities);

        assertEquals(1, gardens.size());
    }

    @Test
    /**
     * Given a list of GardenEntities with two GardenEntities
     * When the method toGardens is called on the GardenConverterImpl
     * 1. The method should return a list with two Gardens
     */
    void toGardens_withTwoGardens() {
        GardenEntity gardenEntity1 = new GardenEntity();
        GardenEntity gardenEntity2 = new GardenEntity();
        List<GardenEntity> gardenEntities = List.of(gardenEntity1, gardenEntity2);

        List<Garden> gardens = gardenConverter.toGardens(gardenEntities);

        assertEquals(2, gardens.size());
    }

    @Test
    /**
     * Given a valid Garden and an empty GardenEntity
     * When the method fillGardenEntity is called on the GardenConverterImpl
     * 1. The GardenEntity should have the same name as the Garden
     * 2. The GardenEntity should have the same description as the Garden
     */
    void fillGardenEntity() {
        Garden garden = new Garden();
        garden.setName("TestGarden");
        garden.setDescription("TestDescription");
        GardenEntity gardenEntity = new GardenEntity();

        gardenConverter.fillGardenEntity(gardenEntity, garden);

        assertEquals(garden.getName(), gardenEntity.getName());
        assertEquals(garden.getDescription(), gardenEntity.getDescription());
    }
}
